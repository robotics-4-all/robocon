from typing import Any
import rclpy
from rclpy.node import Node

from commlib.endpoints import endpoint_factory, EndpointType, TransportType
from ros2_msg_transform import (
    ros2_msg_to_dict, dict_to_ros2_msg_from_ns, dict_to_ros2_msg,
    dict_to_ros2_srv_from_ns
)

from safe_eval import safe_eval

class DotDict(dict):
    """A dictionary that allows dot notation access to its items."""
    def __getattr__(self, name):
        try:
            value = self[name]
            if isinstance(value, dict):
                return DotDict(value)
            return value
        except KeyError:
            raise AttributeError(name)


class B2RServiceBridge:

    def __init__(self, nh, ros_uri: str, msg_type: Any, broker_type: Any, broker_uri, broker_conn_params):
        self.nh = nh
        self.ros_uri = ros_uri
        self.broker_uri = broker_uri
        self.msg_type = msg_type
        self.broker_type = broker_type
        self.broker_conn_params = broker_conn_params

        self._init_ros_endpoint()
        self._init_broker_endpoint()

    def _init_ros_endpoint(self):
        self.ros_client = self.nh.create_client(self.msg_type, self.ros_uri)
        tcount = 1.0
        max_tcount = 10.0
        while not self.ros_client.wait_for_service(timeout_sec=tcount):
            self.nh.get_logger().info(
                'ROS Service not available, waiting again...')
            if tcount > max_tcount:
                print('[ERROR] - ROS Service connection timeout!')
                break
            tcount += 1.0

    def _init_broker_endpoint(self):
        self.bservice = endpoint_factory(EndpointType.RPCService,
            self.broker_type)(
            rpc_name=self.broker_uri,
            on_request=self.on_request,
            conn_params=self.broker_conn_params
        )
        self.bservice.run()

    def on_request(self, data):
        _req = dict_to_ros2_msg(data, self.msg_type.Request)
        self.nh.get_logger().info(f'Calling Service: {self.ros_uri}')
        future = self.send_request(_req)
        resp = self.wait_for_ros_resp(future)
        _dresp = ros2_msg_to_dict(resp)
        return _dresp

    def send_request(self, req):
        future = self.ros_client.call_async(req)
        rclpy.spin_until_future_complete(self.nh, future)
        return future.result()


class B2RTopicBridge:

    def __init__(self, nh, ros_topic: str, msg_type: Any, broker_type: Any, broker_uri, broker_conn_params, transform=None, condition=None, condition_type=None):
        self.nh = nh
        self.ros_topic = ros_topic
        self.broker_uri = broker_uri
        self.msg_type = msg_type
        self.broker_type = broker_type
        self.broker_conn_params = broker_conn_params
        self.transform = transform
        self.condition = condition
        self.condition_type = condition_type

        self._init_ros_endpoint()
        self._init_broker_endpoint()

    def _init_ros_endpoint(self):
        self.ros_pub = self.nh.create_publisher(self.msg_type, self.ros_topic, 10)

    def _init_broker_endpoint(self):
        self.bsub = endpoint_factory(EndpointType.Subscriber,
            self.broker_type)(
            topic=self.broker_uri,
            on_message=self.on_msg,
            conn_params=self.broker_conn_params
        )
        self.bsub.run()

    def on_msg(self, data):
        # Check condition first
        if self.condition is not None:
            context = DotDict(data)
            try:
                condition_met = safe_eval(self.condition, {"msg": context, "data": context})
                should_forward = condition_met if self.condition_type == 'when' else not condition_met
                if not should_forward:
                    self.nh.get_logger().debug(f"Message filtered out by '{self.condition_type}' condition")
                    return
            except Exception as e:
                self.nh.get_logger().error(f"Condition evaluation error: {e}")
                return
        
        if self.transform:
            context = DotDict(data)
            transformed_data = {}
            for target, expr in self.transform.items():
                try:
                    transformed_data[target] = safe_eval(expr, {"msg": context, "data": context})
                except Exception as e:
                    self.nh.get_logger().error(f"Transformation error: {e}")
            data = transformed_data
        _msg = dict_to_ros2_msg(data, self.msg_type)
        self.nh.get_logger().info('Publishing: "%s"' % _msg)
        self.ros_pub.publish(_msg)


class R2BTopicBridge:

    def __init__(self, nh, ros_topic: str, msg_type: Any, broker_type: Any, broker_uri, broker_conn_params, transform=None, condition=None, condition_type=None):
        self.nh = nh
        self.ros_topic = ros_topic
        self.broker_uri = broker_uri
        self.msg_type = msg_type
        self.broker_type = broker_type
        self.broker_conn_params = broker_conn_params
        self.transform = transform
        self.condition = condition
        self.condition_type = condition_type

        self._init_ros_endpoint()
        self._init_broker_endpoint()

    def _init_ros_endpoint(self):
        self.nh.ros_sub = self.nh.create_subscription(
            self.msg_type,
            self.ros_topic,
            self.on_msg,
            10)

    def _init_broker_endpoint(self):
        self.bpub = endpoint_factory(EndpointType.Publisher,
            self.broker_type)(
            topic=self.broker_uri,
            conn_params=self.broker_conn_params
        )

    def on_msg(self, msg):
        _data = ros2_msg_to_dict(msg)
        
        # Check condition first
        if self.condition is not None:
            context = DotDict(_data)
            try:
                condition_met = safe_eval(self.condition, {"msg": context, "data": context})
                should_forward = condition_met if self.condition_type == 'when' else not condition_met
                if not should_forward:
                    self.nh.get_logger().debug(f"Message filtered out by '{self.condition_type}' condition")
                    return
            except Exception as e:
                self.nh.get_logger().error(f"Condition evaluation error: {e}")
                return
        
        if self.transform:
            context = DotDict(_data)
            transformed_data = {}
            for target, expr in self.transform.items():
                try:
                    transformed_data[target] = safe_eval(expr, {"msg": context, "data": context})
                except Exception as e:
                    self.nh.get_logger().error(f"Transformation error: {e}")
            _data = transformed_data
        self.nh.get_logger().info('Publishing: "%s"' % _data)
        self.bpub.publish(_data)


class TFBridge:
    def __init__(self, nh, broker_type: Any, broker_prefix: str, broker_conn_params):
        self.nh = nh
        self.broker_prefix = broker_prefix
        self.broker_type = broker_type
        self.broker_conn_params = broker_conn_params

        from tf2_msgs.msg import TFMessage
        from tf2_web_republisher.msg import TFSubscriptionActionGoal

        self.tf_br = R2BTopicBridge(
            nh, '/tf', TFMessage, broker_type,
            f'{broker_prefix}/tf', broker_conn_params
        )
        self.tf_static_br = R2BTopicBridge(
            nh, '/tf_static', TFMessage, broker_type,
            f'{broker_prefix}/tf_static', broker_conn_params
        )
        self.tf_web_br = R2BTopicBridge(
            nh, '/tf2_web_republisher', TFSubscriptionActionGoal,
            broker_type, f'{broker_prefix}/tf2_web_republisher',
            broker_conn_params
        )